// automatically generated by the FlatBuffers compiler, do not modify


#ifndef FLATBUFFERS_GENERATED_BLOCKMETADATA_H_
#define FLATBUFFERS_GENERATED_BLOCKMETADATA_H_

#include "flatbuffers/flatbuffers.h"

struct PartitionMetadata;

struct BlockMetadata;

struct BlocksMetadata;

FLATBUFFERS_MANUALLY_ALIGNED_STRUCT(8) PartitionMetadata FLATBUFFERS_FINAL_CLASS {
 private:
  uint16_t shuffleId_;
  uint16_t mapId_;
  uint16_t reduceId_;
  int16_t padding0__;
  uint64_t buffer_;
  uint64_t size_;
  uint64_t rkey_;

 public:
  PartitionMetadata() {
    memset(static_cast<void *>(this), 0, sizeof(PartitionMetadata));
  }
  PartitionMetadata(uint16_t _shuffleId, uint16_t _mapId, uint16_t _reduceId, uint64_t _buffer, uint64_t _size, uint64_t _rkey)
      : shuffleId_(flatbuffers::EndianScalar(_shuffleId)),
        mapId_(flatbuffers::EndianScalar(_mapId)),
        reduceId_(flatbuffers::EndianScalar(_reduceId)),
        padding0__(0),
        buffer_(flatbuffers::EndianScalar(_buffer)),
        size_(flatbuffers::EndianScalar(_size)),
        rkey_(flatbuffers::EndianScalar(_rkey)) {
    (void)padding0__;
  }
  uint16_t shuffleId() const {
    return flatbuffers::EndianScalar(shuffleId_);
  }
  uint16_t mapId() const {
    return flatbuffers::EndianScalar(mapId_);
  }
  uint16_t reduceId() const {
    return flatbuffers::EndianScalar(reduceId_);
  }
  uint64_t buffer() const {
    return flatbuffers::EndianScalar(buffer_);
  }
  uint64_t size() const {
    return flatbuffers::EndianScalar(size_);
  }
  uint64_t rkey() const {
    return flatbuffers::EndianScalar(rkey_);
  }
};
FLATBUFFERS_STRUCT_END(PartitionMetadata, 32);

struct BlockMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_PARTITIONMETADATA = 4
  };
  const flatbuffers::Vector<const PartitionMetadata *> *partitionMetadata() const {
    return GetPointer<const flatbuffers::Vector<const PartitionMetadata *> *>(VT_PARTITIONMETADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_PARTITIONMETADATA) &&
           verifier.VerifyVector(partitionMetadata()) &&
           verifier.EndTable();
  }
};

struct BlockMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_partitionMetadata(flatbuffers::Offset<flatbuffers::Vector<const PartitionMetadata *>> partitionMetadata) {
    fbb_.AddOffset(BlockMetadata::VT_PARTITIONMETADATA, partitionMetadata);
  }
  explicit BlockMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlockMetadataBuilder &operator=(const BlockMetadataBuilder &);
  flatbuffers::Offset<BlockMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlockMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlockMetadata> CreateBlockMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<const PartitionMetadata *>> partitionMetadata = 0) {
  BlockMetadataBuilder builder_(_fbb);
  builder_.add_partitionMetadata(partitionMetadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlockMetadata> CreateBlockMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<PartitionMetadata> *partitionMetadata = nullptr) {
  auto partitionMetadata__ = partitionMetadata ? _fbb.CreateVectorOfStructs<PartitionMetadata>(*partitionMetadata) : 0;
  return CreateBlockMetadata(
      _fbb,
      partitionMetadata__);
}

struct BlocksMetadata FLATBUFFERS_FINAL_CLASS : private flatbuffers::Table {
  enum FlatBuffersVTableOffset FLATBUFFERS_VTABLE_UNDERLYING_TYPE {
    VT_BLOCKMETADATA = 4
  };
  const flatbuffers::Vector<flatbuffers::Offset<BlockMetadata>> *blockMetadata() const {
    return GetPointer<const flatbuffers::Vector<flatbuffers::Offset<BlockMetadata>> *>(VT_BLOCKMETADATA);
  }
  bool Verify(flatbuffers::Verifier &verifier) const {
    return VerifyTableStart(verifier) &&
           VerifyOffset(verifier, VT_BLOCKMETADATA) &&
           verifier.VerifyVector(blockMetadata()) &&
           verifier.VerifyVectorOfTables(blockMetadata()) &&
           verifier.EndTable();
  }
};

struct BlocksMetadataBuilder {
  flatbuffers::FlatBufferBuilder &fbb_;
  flatbuffers::uoffset_t start_;
  void add_blockMetadata(flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlockMetadata>>> blockMetadata) {
    fbb_.AddOffset(BlocksMetadata::VT_BLOCKMETADATA, blockMetadata);
  }
  explicit BlocksMetadataBuilder(flatbuffers::FlatBufferBuilder &_fbb)
        : fbb_(_fbb) {
    start_ = fbb_.StartTable();
  }
  BlocksMetadataBuilder &operator=(const BlocksMetadataBuilder &);
  flatbuffers::Offset<BlocksMetadata> Finish() {
    const auto end = fbb_.EndTable(start_);
    auto o = flatbuffers::Offset<BlocksMetadata>(end);
    return o;
  }
};

inline flatbuffers::Offset<BlocksMetadata> CreateBlocksMetadata(
    flatbuffers::FlatBufferBuilder &_fbb,
    flatbuffers::Offset<flatbuffers::Vector<flatbuffers::Offset<BlockMetadata>>> blockMetadata = 0) {
  BlocksMetadataBuilder builder_(_fbb);
  builder_.add_blockMetadata(blockMetadata);
  return builder_.Finish();
}

inline flatbuffers::Offset<BlocksMetadata> CreateBlocksMetadataDirect(
    flatbuffers::FlatBufferBuilder &_fbb,
    const std::vector<flatbuffers::Offset<BlockMetadata>> *blockMetadata = nullptr) {
  auto blockMetadata__ = blockMetadata ? _fbb.CreateVector<flatbuffers::Offset<BlockMetadata>>(*blockMetadata) : 0;
  return CreateBlocksMetadata(
      _fbb,
      blockMetadata__);
}

#endif  // FLATBUFFERS_GENERATED_BLOCKMETADATA_H_
